// generated by mBlock5 for MegaPi
// codes make you happy

#include <Arduino.h>
#include <Wire.h>
#include <SoftwareSerial.h>
#include "MeLineFollower.h"
#include "MeCollisionSensor.h"
#include "MeBarrierSensor.h"
#include "MeNewRGBLed.h"
#include <MeMegaPi.h>

MeMegaPiDCMotor motor_1(1);
MeMegaPiDCMotor motor_9(9);
MeMegaPiDCMotor motor_10(10);
MeMegaPiDCMotor motor_2(2);
MeMegaPiDCMotor motor_3(3);
MeMegaPiDCMotor motor_11(11);
MeMegaPiDCMotor motor_4(4);
MeMegaPiDCMotor motor_12(12);
MeCollisionSensor collision_65(65);
MeCollisionSensor collision_66(66);
MeBarrierSensor barrier_60(60);
MeBarrierSensor barrier_61(61);
MeBarrierSensor barrier_62(62);
MeSingleLineFollower linefollower_63(63);
MeSingleLineFollower linefollower_64(64);
double angle_rad = PI/180.0;
double angle_deg = 180.0/PI;

int reverse_speed = 19;
int forward_speed = 19;

void spin_in_Place_clockwise (){

  motor_1.run(forward_speed / 100.0 * 255);

  motor_9.run(reverse_speed / 100.0 * 255);

  motor_10.run(reverse_speed / 100.0 * 255);

  motor_2.run(forward_speed / 100.0 * 255);
  _delay(0.005);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}

void Straight_Crash (){

  motor_1.run(forward_speed / 100.0 * 255);

  motor_9.run(forward_speed / 100.0 * 255);

  motor_2.run(forward_speed / 100.0 * 255);

  motor_10.run(forward_speed / 100.0 * 255);
  _delay(0.5);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}
void Straight (){

  motor_1.run(forward_speed / 100.0 * 255);

  motor_9.run(forward_speed / 100.0 * 255);

  motor_2.run(forward_speed / 100.0 * 255);

  motor_10.run(forward_speed / 100.0 * 255);
  _delay(0.005);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}
void Correct_left (){

  motor_1.run(forward_speed / 100.0 * 255);

  motor_9.run(forward_speed / 100.0 * 255);
  _delay(0.005);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}
void Reverse_collision (){

  motor_1.run(reverse_speed / 100.0 * 255);

  motor_9.run(reverse_speed / 100.0 * 255);

  motor_2.run(reverse_speed / 100.0 * 255);

  motor_10.run(reverse_speed / 100.0 * 255);
  _delay(0.5);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}
void Reverse (){

  motor_1.run(reverse_speed / 100.0 * 255);

  motor_9.run(reverse_speed / 100.0 * 255);

  motor_2.run(reverse_speed / 100.0 * 255);

  motor_10.run(reverse_speed / 100.0 * 255);
  _delay(0.005);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}
void my_180_degree_turn (){

  motor_1.run(forward_speed / 100.0 * 255);

  motor_10.run(reverse_speed / 100.0 * 255);
  _delay(1);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}
void Correct_right (){

  motor_2.run(forward_speed / 100.0 * 255);

  motor_10.run(forward_speed / 100.0 * 255);
  _delay(0.005);

  motor_1.run(0);
  motor_9.run(0);
  motor_2.run(0);
  motor_10.run(0);
  motor_3.run(0);
  motor_11.run(0);
  motor_4.run(0);
  motor_12.run(0);

}

void _delay(float seconds) {
  if(seconds < 0.0){
    seconds = 0.0;
  }
  long endTime = millis() + seconds * 1000;
  while(millis() < endTime) _loop();
}

void setup() {
  TCCR1A = _BV(WGM10);
  TCCR1B = _BV(CS11) | _BV(WGM12);
  TCCR2A = _BV(WGM21) | _BV(WGM20);
  TCCR2B = _BV(CS21);

  forward_speed = 19;
  reverse_speed = -19;

}

void _loop() {
}

void loop() {
  if(collision_65.isCollision()){
      Straight_Crash();

  }
  if(collision_66.isCollision()){
      Straight_Crash();

  }
  if(barrier_60.isBarried()){
      Reverse_collision();
      my_180_degree_turn();

  }
  if(barrier_61.isBarried()){
      Reverse_collision();
      my_180_degree_turn();

  }
  if(barrier_62.isBarried()){
      Reverse_collision();
      my_180_degree_turn();

  }
  if(((linefollower_63.readSensor() == 0))  &&  ((linefollower_64.readSensor() == 1))){
      Correct_right();

  }
  if(((linefollower_63.readSensor() == 1))  &&  ((linefollower_64.readSensor() == 0))){
      Correct_left();

  }
  if(((linefollower_63.readSensor() == 0))  &&  ((linefollower_64.readSensor() == 0))){
      Straight();

  }
  if(((linefollower_63.readSensor() == 1))  &&  ((linefollower_64.readSensor() == 1))){
      spin_in_Place_clockwise();

  }else{

      motor_1.run(0);
      motor_9.run(0);
      motor_2.run(0);
      motor_10.run(0);
      motor_3.run(0);
      motor_11.run(0);
      motor_4.run(0);
      motor_12.run(0);

  }

  _loop();
}
